import os
import logging
import xmlrpclib
import subprocess
from datetime import datetime

from lib.common.constants import PATHS
from lib.core.config import Config
from lib.core.startup import create_folders, init_logging
from lib.api.tracer import SyscallTracer, FilesystemTracer
from time import sleep

log = logging.getLogger()

FILES_LIST = []
DUMPED_LIST = []

def dump_file():
    """Create a copy of the given file path."""
    pass

def dump_files():
    """Dump all the dropped files."""
    for file_path in FILES_LIST:
        dump_file(file_path)

class Analyzer(object):
    def __init__(self):
        self.config = None
        self.target = None

    def prepare(self):
        # Create the folders used for storing the results.
        create_folders()
        
        # Initialize logging.
        init_logging()

        # Parse the analysis configuration file generated by the agent.
        self.config = Config(cfg="analysis.conf")
        
        # Set virtual machine clock
        clock = datetime.strptime(self.config.clock, "%Y%m%dT%H:%M:%S")
        
        # Set date and time
        # And disable stdout using '/dev/null 2>&1'
        os.system("date -s '{0}' > /dev/null 2>&1".format(clock))

        # We update the target according to its category. If it's a file, then
        # we store the path.
        if self.config.category == "file":
            self.target = os.path.join("/tmp", str(self.config.file_name))
            
        # If it's a URL, well.. we store the URL.
        else:
            self.target = self.config.target
    
    def complete(self):
        """ End analysis. """
        # Dump all the notified files
        dump_files()
        
        # We're done!
        log.info("Analysis completed")
        
    def run(self):
        self.prepare()

        log.info("Starting analyzer from: {0}".format(os.getcwd()))
        log.info("Storing results at: {0}".format(PATHS["root"]))
        log.info("Target is: {0}".format(self.target))

        # Make target file executable
        os.system("chmod +x " + str(self.target))
        # Start file system tracer thread
        fstrace = FilesystemTracer()
        fstrace.start()
        # Start system call tracer thread
        proctrace = SyscallTracer([self.target,''])
        proctrace.start()
        '''
        if self.config.category == "file":
            if ".bash" in self.config.file_name:
                subprocess.call(["bash", self.target], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            elif ".sh" in self.config.file_name:
                subprocess.call(["sh", self.target], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            elif ".pl" in self.config.file_name:
                subprocess.call(["perl", self.target], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            else:
                arg = "chmod +x " + str(self.target)
                os.system(arg)
                os.system(self.target)
        '''

        sleep(300)
        # Let's invoke the completion procedure.
        self.complete()

        return True

if __name__ == "__main__":
    success = False
    error = ""

    try:
        # Initialize the main analyzer class.
        analyzer = Analyzer()
        
        # Run it and wait for the response.
        success = analyzer.run()
        
    # This is not likely to happen.
    except KeyboardInterrupt:
        error = "Keyboard Interrupt"
        
    # If the analysis process encountered a critical error, it will raise a
    # CuckooError exception, which will force the termination of the analysis
    # weill notify the agent of the failure. Also catched unexpected
    # exceptions.
    except Exception as e:
        # Store the error.
        error = str(e)

        # Just to be paranoid.
        if len(log.handlers) > 0:
            log.critical(error)
        else:
            sys.stderr.write("{0}\n".format(e))
            
    # Once the analysis is completed or terminated for any reason, we report
    # back to the agent, notifying that it can report back to the host.
    finally:
        # Establish connection with the agent XMLRPC server.
        server = xmlrpclib.Server("http://127.0.0.1:8000")
        server.complete(success, error, PATHS["root"])
        
